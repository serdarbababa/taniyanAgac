using NAudio.Wave;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace rakamTanima
{

   
    public partial class Form1 : Form
    {
        int counter;
        int selectedImageID;
        Spektron s;
        List<Spektron> speks;
        List<PictureBox> listOutputPictureBoxes;
        
        
        
        int numImages;
        int numRows;
           
        
        public static  byte[,,] images ;
        byte[] labels;

        public Form1()
        {
            InitializeComponent();
            counter = 1;
            selectedImageID = 1;
            numImages = 0;
            s = null;
            speks = new List<Spektron>();

            listOutputPictureBoxes = new List<PictureBox>();
            listOutputPictureBoxes.Add(pictureBox2);
            listOutputPictureBoxes.Add(pictureBox3);
            listOutputPictureBoxes.Add(pictureBox4);
            listOutputPictureBoxes.Add(pictureBox5);
            listOutputPictureBoxes.Add(pictureBox6);
            listOutputPictureBoxes.Add(pictureBox7);
            listOutputPictureBoxes.Add(pictureBox8);
            listOutputPictureBoxes.Add(pictureBox9);
            listOutputPictureBoxes.Add(pictureBox10);


        }

        private void BtnResimAc_Click(object sender, EventArgs e)
        {
            counter = counter + 1;
            if (counter > 6)
                counter = 1;
            string a = @"C:\serdar\webPy\OLD\classification\training_images\"+counter+".png";
            pictureBox1.ImageLocation = a;
            
            





        }

        private void MNIST_Click(object sender, EventArgs e)
        {
            byte[,] pixels = new byte[28,28];            

            int zoomFactor = Convert.ToInt32(txtZoom.Text);
            Bitmap bmp = new Bitmap(28 * zoomFactor, 28 * zoomFactor);
            // each test image
            Random random = new Random();
            
            int di = random.Next(0, numImages);
            selectedImageID = di;


                for (int i = 0; i < 28; ++i)
                {
                    for (int j = 0; j < 28; ++j)
                    {
                        
                        pixels[i,j] = images[di,i,j];
                        byte b = pixels[i,j];
                        for (int k = 0; k < zoomFactor; k++)
                            for (int l = 0; l < zoomFactor; l++)
                                bmp.SetPixel(j * zoomFactor + k, i * zoomFactor + l, Color.FromArgb(b, b, b));

                    }
                }
                pictureBox1.Image = (Image)bmp;

                pictureBox1.Show();
                
                txtOutput.AppendText("Label = " + labels[di] +"\t"+ selectedImageID + "\n\n");










                /*
                Bitmap bmp = new Bitmap(5, 5);
                for (int y = 0; y < 5; ++y)
                    for (int x = 0; x < 5; ++x)
                    {
                        int offset = y * 5 * 4 + x * 4;
                        bmp.SetPixel(x, y, Color.FromArgb(data[offset], data[offset + 1], data[offset + 2], data[offset + 3]));
                    }
                bmp.Save(@"c:\tmp.png");

                */
            }

        private void BtnSesOku_Click(object sender, EventArgs e)
        {
            //string txtWave = @"C:\serdar\audio\3ServiceSatisfactionCallB.wav";
            //chart.Series.Clear();
            //chart.Series.Add("wave");
            //chart.Series["wave"].ChartType = System.Windows.Forms.DataVisualization.Charting.SeriesChartType.FastLine;
            //chart.Series["wave"].ChartArea = "ChartArea1";
            //float[] L;
            //float[] R;
            //if (readWav(txtWave, out L, out R))
            //{
            //    for (int i = 0; i < L.Length; i++)
            //    {
            //        chart.Series["wave"].Points.AddXY(i, L[i]);
            //    }
            //}
            //chart.Show();

        }

        /*
        public string run_cmd(string cmd, string args)
        {
            ProcessStartInfo start = new ProcessStartInfo();
            start.FileName = "PATH_TO_PYTHON_EXE";
            start.Arguments = string.Format("\"{0}\" \"{1}\"", cmd, args);
            start.UseShellExecute = false;// Do not use OS shell
            start.CreateNoWindow = true; // We don't need new window
            start.RedirectStandardOutput = true;// Any output, generated by application will be redirected back
            start.RedirectStandardError = true; // Any error in standard output will be redirected back (for example exceptions)
            using (Process process = Process.Start(start))
            {
                using (StreamReader reader = process.StandardOutput)
                {
                    string stderr = process.StandardError.ReadToEnd(); // Here are the exceptions from our Python script
                    string result = reader.ReadToEnd(); // Here is the result of StdOut(for example: print "test")
                    return result;
                }
            }
        }
        static bool readWav(string filename, out float[] L, out float[] R)
        {
            L = R = null;
            //float [] left = new float[1];

            //float [] right;
            try
            {
                using (FileStream fs = File.Open(filename, FileMode.Open))
                {
                    BinaryReader reader = new BinaryReader(fs);

                    // chunk 0
                    int chunkID = reader.ReadInt32();
                    int fileSize = reader.ReadInt32();
                    int riffType = reader.ReadInt32();


                    // chunk 1
                    int fmtID = reader.ReadInt32();
                    int fmtSize = reader.ReadInt32(); // bytes for this chunk
                    int fmtCode = reader.ReadInt16();
                    int channels = reader.ReadInt16();
                    int sampleRate = reader.ReadInt32();
                    int byteRate = reader.ReadInt32();
                    int fmtBlockAlign = reader.ReadInt16();
                    int bitDepth = reader.ReadInt16();

                    if (fmtSize == 18)
                    {
                        // Read any extra values
                        int fmtExtraSize = reader.ReadInt16();
                        reader.ReadBytes(fmtExtraSize);
                    }

                    // chunk 2
                    int dataID = reader.ReadInt32();
                    int bytes = reader.ReadInt32();

                    // DATA!
                    byte[] byteArray = reader.ReadBytes(bytes);

                    int bytesForSamp = bitDepth / 8;
                    int samps = bytes / bytesForSamp;


                    float[] asFloat = null;
                    switch (bitDepth)
                    {
                        case 64:
                            double[]
                            asDouble = new double[samps];
                            Buffer.BlockCopy(byteArray, 0, asDouble, 0, bytes);
                            asFloat = Array.ConvertAll(asDouble, e => (float)e);
                            break;
                        case 32:
                            asFloat = new float[samps];
                            Buffer.BlockCopy(byteArray, 0, asFloat, 0, bytes);
                            break;
                        case 16:
                            Int16[]
                            asInt16 = new Int16[samps];
                            Buffer.BlockCopy(byteArray, 0, asInt16, 0, bytes);
                            asFloat = Array.ConvertAll(asInt16, e => e / (float)Int16.MaxValue);
                            break;
                        default:
                            return false;
                    }

                    switch (channels)
                    {
                        case 1:
                            L = asFloat;
                            R = null;
                            return true;
                        case 2:
                            L = new float[samps];
                            R = new float[samps];
                            for (int i = 0, s = 0; i < samps; i++)
                            {
                                L[i] = asFloat[s++];
                                R[i] = asFloat[s++];
                            }
                            return true;
                        default:
                            return false;
                    }
                }
            }
            catch
            {
                //Debug.Log("...Failed to load note: " + filename);
                return false;
                //left = new float[ 1 ]{ 0f };
            }

            return false;
        }
        */
        private void BtnResimYukle_Click(object sender, EventArgs e)
        {
            if(numImages==0)
                loadImages();

        }


        ///////////////////////////////////////////////////////////////////////////////////////////////
        private void BtnSingleOgren_Click(object sender, EventArgs e)
        {
            int windowSize = Convert.ToInt32(txtWindowSize.Text);
            if (s == null)
                s = new Spektron(windowSize * windowSize, Convert.ToDouble(txtHata.Text));
            if (numImages == 0)
            {
                txtOutput.AppendText("Load Images \n");
                loadImages();
            }
            txtOutput.AppendText("Spektron egtim\n");
            singleTrain(); 
            

        }
        private void BtnSingleMultiImageOgren_Click(object sender, EventArgs e)
        {
            int windowSize = Convert.ToInt32(txtWindowSize.Text);
            if (speks.Count == 0)
            {
                speks.Add(new Spektron(windowSize * windowSize, Convert.ToDouble(txtHata.Text)));
            }
            else
                return;
            if (numImages == 0)
            {
                txtOutput.AppendText("Load Images \n");
                loadImages();
            }
            txtOutput.AppendText("Spektron egtim\n");
            multipleTrain();
        }

        private void BtnSingleMultiImageOgrenL2_Click(object sender, EventArgs e)
        {
            int windowSize = Convert.ToInt32(txtWindowSize.Text);
            if (speks.Count == 1)
            {
                speks.Add(new Spektron(windowSize * windowSize, Convert.ToDouble(txtHata.Text)));
            }
            else return;

            
            txtOutput.AppendText("Spektron egtim L2 \n");
            multipleTrain2();
        }

        private void BtnSingleMultiImageOgrenL3_Click(object sender, EventArgs e)
        {
            int windowSize = Convert.ToInt32(txtWindowSize.Text);
            if (speks.Count == 2)
            {
                speks.Add(new Spektron(windowSize * windowSize, Convert.ToDouble(txtHata.Text)));
            }
            else return;
            
            txtOutput.AppendText("Spektron egtim L3 \n");
            multipleTrain3();
        }

        private void BtnSingleTest_Click(object sender, EventArgs e)
        {
            if (speks.Count == 0)
            {
                txtOutput.AppendText("Please Train the system \n");
                return;
            }
            multipleTest();



        }
        private void BtnSingleReset_Click(object sender, EventArgs e)
        {
            speks.Clear();
            //int windowSize = Convert.ToInt32(txtWindowSize.Text);
            //s = new Spektron(windowSize * windowSize, Convert.ToDouble(txtHata.Text));
        }
        ///////////////////////////////////////////////////////////////////////////////////////////////

        private void BtnFiltreOgren_Click(object sender, EventArgs e)
        {
            int windowSize = Convert.ToInt32(txtWindowSize.Text);
            if (s==null)
                s = new Spektron(windowSize*windowSize, Convert.ToDouble(txtHata.Text));
            if (numImages == 0) { 
                txtOutput.AppendText("Load Images \n");
                loadImages();
            }
            txtOutput.AppendText("Spektron egtim\n");
            train(s);
            
        }

        private void BtnFullOgren_Click(object sender, EventArgs e)
        {
            int windowSize = Convert.ToInt32(txtWindowSize.Text);
            if (s == null)
                s = new Spektron(windowSize * windowSize, Convert.ToDouble(txtHata.Text));
            if (numImages == 0)
            {
                txtOutput.AppendText("Load Images \n");
                loadImages();
            }
            txtOutput.AppendText("Spektron egtim\n");
            fullTrain(s);

        }

        private void BtnTest_Click(object sender, EventArgs e)
        {
            txtOutput.AppendText("Spektron test\n");
            if (s != null)
                test(s);
            
        }

        private void BtnShowSpektron_Click(object sender, EventArgs e)
        {
            if (s != null)
                s.yazdir();
        }
        private void BtnReset_Click(object sender, EventArgs e)
        {
            int windowSize = Convert.ToInt32(txtWindowSize.Text);
            s = new Spektron(windowSize* windowSize, Convert.ToDouble(txtHata.Text));
        }


        ///////////////////////////////////////////////////////////////////////////////////////////////
        private void BtnCokSpektronOgren_Click(object sender, EventArgs e)
        {
            int windowOffset = Convert.ToInt32(txtWindowJump.Text);
            int windowSize = Convert.ToInt32(txtWindowSize.Text);
            for (int i = 0; i < numRows - windowSize+1; i+=windowOffset)
                for (int j = 0; j < numRows - windowSize+1; j+=windowOffset)
                {
                    speks.Add(new Spektron(windowSize, Convert.ToDouble(txtHata.Text)));
                    txtXCoord.Text = i+"";
                    txtYCoord.Text = j + "";
                    train(speks[speks.Count - 1]);
                }
        }
        private void BtnCokSpektronReset_Click(object sender, EventArgs e)
        {
            speks.Clear();
        }
        ///////////////////////////////////////////////////////////////////////////////////////////////
        /// <summary>
        /// helping functions
        /// </summary>



        //load MNIST dataset   
        public void loadImages()
        {
            FileStream ifsLabels = new FileStream(@"C:\serdar\code\taniyanAgac\MNIST_data\t10k-labels.idx1-ubyte", FileMode.Open); // test labels
            FileStream ifsImages = new FileStream(@"C:\serdar\code\taniyanAgac\MNIST_data\t10k-images.idx3-ubyte", FileMode.Open); // test images

            BinaryReader brLabels = new BinaryReader(ifsLabels);
            BinaryReader brImages = new BinaryReader(ifsImages);

            int magic1 = brImages.ReadInt32(); // discard
            numImages = brImages.ReadInt32();
            numRows = brImages.ReadInt32();
            int numCols = brImages.ReadInt32();

            int magic2 = brLabels.ReadInt32();
            int numLabels = brLabels.ReadInt32();

            numImages = 9000;
            numRows = 28;
            numCols = 28;
            numLabels = numImages;


            images = new byte[numImages, numRows, numCols];
            labels = new byte[numLabels];


            for (int di = 0; di < numImages; ++di)
            {
                for (int i = 0; i < 28; ++i)
                {
                    for (int j = 0; j < 28; ++j)
                    {
                        images[di, i, j] = brImages.ReadByte();
                    }
                }
                labels[di] = brLabels.ReadByte();
            }




            ifsImages.Close();
            brImages.Close();
            ifsLabels.Close();
            brLabels.Close();

        }

        public void singleTrain()
        {

            //int xoffset = Convert.ToInt32(txtXCoord.Text);
            //int yoffset = Convert.ToInt32(txtYCoord.Text);
            int windowOffset = Convert.ToInt32(txtWindowJump.Text);
            int di = Convert.ToInt32(txtImageID.Text);
                
            double[] data = new double[s.branchLength];
            for (int xoffset = 0; xoffset < numRows - s.windowLength+1; xoffset+= windowOffset)
                for (int yoffset = 0; yoffset < numRows - s.windowLength+1; yoffset+= windowOffset)
                {
                    double maxVal=1;
                    for (int i = 0; i < s.windowLength; i++)
                    {
                        for (int j = 0; j < s.windowLength; j++)
                        {
                            data[i * s.windowLength + j] = Convert.ToDouble(images[Convert.ToInt32(txtImageID.Text) + di, i + yoffset, j + xoffset]) / 255;
                            if (cbxNormalize.Checked)
                                data[i * s.windowLength + j] = Math.Round(data[i * s.windowLength + j], 1);
                            if (maxVal < data[i * s.windowLength + j])
                                maxVal = data[i * s.windowLength + j];
                        }
                    }
                    if (cbxLocalNormalize.Checked)
                        for (int i = 0; i < s.windowLength; i++)
                            for (int j = 0; j < s.windowLength; j++)
                                data[i * s.windowLength + j] /= maxVal;
                    s.learn(data);
                }
            
            //txtOutput.AppendText("branch = "+ s.learn(data) + "\r\n");
            showMNISTImage(di);
            
            txtOutput.AppendText("\n\n");
                //resimGoster[s.]
            txtOutput.AppendText(s.yazdir() + "\n");
            
        }

        public void multipleTrain()
        {   
            int windowOffset = Convert.ToInt32(txtWindowJump.Text);
            Spektron s = speks[0];
            for (int di = 0; di < 900; di++) {
                double[] data = new double[s.branchLength];
                for (int xoffset = 0; xoffset < numRows - s.windowLength + 1; xoffset += windowOffset)
                    for (int yoffset = 0; yoffset < numRows - s.windowLength + 1; yoffset += windowOffset)
                    {
                        double maxVal = 1;
                        for (int i = 0; i < s.windowLength; i++)
                        {
                            for (int j = 0; j < s.windowLength; j++)
                            {
                                data[i * s.windowLength + j] = Convert.ToDouble(images[Convert.ToInt32(txtImageID.Text) + di, i + yoffset, j + xoffset]) / 255;
                                if (cbxNormalize.Checked)
                                    data[i * s.windowLength + j] = Math.Round(data[i * s.windowLength + j], 1);
                                if (maxVal < data[i * s.windowLength + j])
                                    maxVal = data[i * s.windowLength + j];
                            }
                        }
                        if (cbxLocalNormalize.Checked)
                            for (int i = 0; i < s.windowLength; i++)
                                for (int j = 0; j < s.windowLength; j++)
                                    data[i * s.windowLength + j] /= maxVal;
                        s.learn(data);
                    }
            }

            speks[0] = s;

            //s = speks[1];
            //for (int di = 0; di < 900; di++)
            //{
            //    double[] data1 = new double[s.branchLength];
            //    double[] data = new double[s.branchLength];
            //    for (int xoffset = 0; xoffset < numRows - s.windowLength + 1; xoffset += windowOffset)
            //        for (int yoffset = 0; yoffset < numRows - s.windowLength + 1; yoffset += windowOffset)
            //        {
            //            double maxVal = 1;
            //            for (int i = 0; i < s.windowLength; i++)
            //            {
            //                for (int j = 0; j < s.windowLength; j++)
            //                {
            //                    data[i * s.windowLength + j] = Convert.ToDouble(images[Convert.ToInt32(txtImageID.Text) + di, i + yoffset, j + xoffset]) / 255;
            //                    if (cbxNormalize.Checked)
            //                        data[i * s.windowLength + j] = Math.Round(data[i * s.windowLength + j], 1);
            //                    if (maxVal < data[i * s.windowLength + j])
            //                        maxVal = data[i * s.windowLength + j];
            //                }
            //            }
            //            if (cbxLocalNormalize.Checked)
            //                for (int i = 0; i < s.windowLength; i++)
            //                    for (int j = 0; j < s.windowLength; j++)
            //                        data[i * s.windowLength + j] /= maxVal;
            //            s.learn(data);
            //        }
            //}

            //speks[1] = s;
            //s = speks[1];
            //for (int di = 0; di < 900; di++)
            //{
            //    double[] data = new double[s.branchLength];
            //    for (int xoffset = 0; xoffset < numRows - s.windowLength + 1; xoffset += windowOffset)
            //        for (int yoffset = 0; yoffset < numRows - s.windowLength + 1; yoffset += windowOffset)
            //        {
            //            double maxVal = 1;
            //            for (int i = 0; i < s.windowLength; i++)
            //            {
            //                for (int j = 0; j < s.windowLength; j++)
            //                {
            //                    data[i * s.windowLength + j] = Convert.ToDouble(images[Convert.ToInt32(txtImageID.Text) + di, i + yoffset, j + xoffset]) / 255;
            //                    if (cbxNormalize.Checked)
            //                        data[i * s.windowLength + j] = Math.Round(data[i * s.windowLength + j], 1);
            //                    if (maxVal < data[i * s.windowLength + j])
            //                        maxVal = data[i * s.windowLength + j];
            //                }
            //            }
            //            if (cbxLocalNormalize.Checked)
            //                for (int i = 0; i < s.windowLength; i++)
            //                    for (int j = 0; j < s.windowLength; j++)
            //                        data[i * s.windowLength + j] /= maxVal;
            //            s.learn(data);
            //        }
            //}

            //speks[2] = s;

            //txtOutput.AppendText("branch = "+ s.learn(data) + "\r\n");
            //showMNISTImage(di);

            txtOutput.AppendText("\n\n");
            //resimGoster[s.]
            txtOutput.AppendText(speks[0].yazdir() + "\n");

        }

        public void multipleTrain2()
        {
            int windowOffset = Convert.ToInt32(txtWindowJump.Text);
            Spektron s = speks[0];
            
            s = speks[1];
            for (int di = 0; di < 900; di++)
            {
                double[] data1 = new double[s.branchLength];
                double[] data = new double[s.branchLength];

                //for (int x = 0; x < 9; x++) {
                //    for (int y = 0; y < 9; y++)
                //    {
                //        for (int xoffset = 0; xoffset < numRows - s.windowLength + 1; xoffset += windowOffset)
                //            for (int yoffset = 0; yoffset < numRows - s.windowLength + 1; yoffset += windowOffset)
                //    }
                //}

                for (int xoffset = 0; xoffset < numRows - s.windowLength + 1; xoffset += windowOffset)
                    for (int yoffset = 0; yoffset < numRows - s.windowLength + 1; yoffset += windowOffset)
                    {
                        double maxVal = 1;
                        for (int i = 0; i < s.windowLength; i++)
                        {
                            for (int j = 0; j < s.windowLength; j++)
                            {
                                data[i * s.windowLength + j] = Convert.ToDouble(images[Convert.ToInt32(txtImageID.Text) + di, i + yoffset, j + xoffset]) / 255;
                                if (cbxNormalize.Checked)
                                    data[i * s.windowLength + j] = Math.Round(data[i * s.windowLength + j], 1);
                                if (maxVal < data[i * s.windowLength + j])
                                    maxVal = data[i * s.windowLength + j];
                            }
                        }
                        if (cbxLocalNormalize.Checked)
                            for (int i = 0; i < s.windowLength; i++)
                                for (int j = 0; j < s.windowLength; j++)
                                    data[i * s.windowLength + j] /= maxVal;
                        s.learn(data);
                    }
            }

            speks[1] = s;
            //s = speks[1];
            //for (int di = 0; di < 900; di++)
            //{
            //    double[] data = new double[s.branchLength];
            //    for (int xoffset = 0; xoffset < numRows - s.windowLength + 1; xoffset += windowOffset)
            //        for (int yoffset = 0; yoffset < numRows - s.windowLength + 1; yoffset += windowOffset)
            //        {
            //            double maxVal = 1;
            //            for (int i = 0; i < s.windowLength; i++)
            //            {
            //                for (int j = 0; j < s.windowLength; j++)
            //                {
            //                    data[i * s.windowLength + j] = Convert.ToDouble(images[Convert.ToInt32(txtImageID.Text) + di, i + yoffset, j + xoffset]) / 255;
            //                    if (cbxNormalize.Checked)
            //                        data[i * s.windowLength + j] = Math.Round(data[i * s.windowLength + j], 1);
            //                    if (maxVal < data[i * s.windowLength + j])
            //                        maxVal = data[i * s.windowLength + j];
            //                }
            //            }
            //            if (cbxLocalNormalize.Checked)
            //                for (int i = 0; i < s.windowLength; i++)
            //                    for (int j = 0; j < s.windowLength; j++)
            //                        data[i * s.windowLength + j] /= maxVal;
            //            s.learn(data);
            //        }
            //}

            //speks[2] = s;

            //txtOutput.AppendText("branch = "+ s.learn(data) + "\r\n");
            //showMNISTImage(di);

            txtOutput.AppendText("\n\n");
            //resimGoster[s.]
            txtOutput.AppendText(speks[0].yazdir() + "\n");

        }

        public void multipleTrain3()
        {
            int windowOffset = Convert.ToInt32(txtWindowJump.Text);
            Spektron s = speks[0];
            for (int di = 0; di < 900; di++)
            {
                double[] data = new double[s.branchLength];
                for (int xoffset = 0; xoffset < numRows - s.windowLength + 1; xoffset += windowOffset)
                    for (int yoffset = 0; yoffset < numRows - s.windowLength + 1; yoffset += windowOffset)
                    {
                        double maxVal = 1;
                        for (int i = 0; i < s.windowLength; i++)
                        {
                            for (int j = 0; j < s.windowLength; j++)
                            {
                                data[i * s.windowLength + j] = Convert.ToDouble(images[Convert.ToInt32(txtImageID.Text) + di, i + yoffset, j + xoffset]) / 255;
                                if (cbxNormalize.Checked)
                                    data[i * s.windowLength + j] = Math.Round(data[i * s.windowLength + j], 1);
                                if (maxVal < data[i * s.windowLength + j])
                                    maxVal = data[i * s.windowLength + j];
                            }
                        }
                        if (cbxLocalNormalize.Checked)
                            for (int i = 0; i < s.windowLength; i++)
                                for (int j = 0; j < s.windowLength; j++)
                                    data[i * s.windowLength + j] /= maxVal;
                        s.learn(data);
                    }
            }

            speks[0] = s;

            s = speks[1];
            for (int di = 0; di < 900; di++)
            {
                double[] data1 = new double[s.branchLength];
                double[] data = new double[s.branchLength];
                for (int xoffset = 0; xoffset < numRows - s.windowLength + 1; xoffset += windowOffset)
                    for (int yoffset = 0; yoffset < numRows - s.windowLength + 1; yoffset += windowOffset)
                    {
                        double maxVal = 1;
                        for (int i = 0; i < s.windowLength; i++)
                        {
                            for (int j = 0; j < s.windowLength; j++)
                            {
                                data[i * s.windowLength + j] = Convert.ToDouble(images[Convert.ToInt32(txtImageID.Text) + di, i + yoffset, j + xoffset]) / 255;
                                if (cbxNormalize.Checked)
                                    data[i * s.windowLength + j] = Math.Round(data[i * s.windowLength + j], 1);
                                if (maxVal < data[i * s.windowLength + j])
                                    maxVal = data[i * s.windowLength + j];
                            }
                        }
                        if (cbxLocalNormalize.Checked)
                            for (int i = 0; i < s.windowLength; i++)
                                for (int j = 0; j < s.windowLength; j++)
                                    data[i * s.windowLength + j] /= maxVal;
                        s.learn(data);
                    }
            }

            speks[1] = s;
            //s = speks[1];
            //for (int di = 0; di < 900; di++)
            //{
            //    double[] data = new double[s.branchLength];
            //    for (int xoffset = 0; xoffset < numRows - s.windowLength + 1; xoffset += windowOffset)
            //        for (int yoffset = 0; yoffset < numRows - s.windowLength + 1; yoffset += windowOffset)
            //        {
            //            double maxVal = 1;
            //            for (int i = 0; i < s.windowLength; i++)
            //            {
            //                for (int j = 0; j < s.windowLength; j++)
            //                {
            //                    data[i * s.windowLength + j] = Convert.ToDouble(images[Convert.ToInt32(txtImageID.Text) + di, i + yoffset, j + xoffset]) / 255;
            //                    if (cbxNormalize.Checked)
            //                        data[i * s.windowLength + j] = Math.Round(data[i * s.windowLength + j], 1);
            //                    if (maxVal < data[i * s.windowLength + j])
            //                        maxVal = data[i * s.windowLength + j];
            //                }
            //            }
            //            if (cbxLocalNormalize.Checked)
            //                for (int i = 0; i < s.windowLength; i++)
            //                    for (int j = 0; j < s.windowLength; j++)
            //                        data[i * s.windowLength + j] /= maxVal;
            //            s.learn(data);
            //        }
            //}

            //speks[2] = s;

            //txtOutput.AppendText("branch = "+ s.learn(data) + "\r\n");
            //showMNISTImage(di);

            txtOutput.AppendText("\n\n");
            //resimGoster[s.]
            txtOutput.AppendText(speks[0].yazdir() + "\n");

        }
        public void multipleTest()
        {

        }

        public void train(Spektron s)
        {
            int windowOffset = Convert.ToInt32(txtWindowJump.Text);
            int xoffset = Convert.ToInt32(txtXCoord.Text);
            int yoffset = Convert.ToInt32(txtYCoord.Text);

            for (int di = 0; di < 900; di++)
            {
                double[] data = new double[s.branchLength];
                double maxVal = 1;
                for (int i = 0; i < s.windowLength; i++)
                {
                    for (int j = 0; j < s.windowLength; j++)
                    {
                        data[i * s.windowLength + j] = Convert.ToDouble(images[Convert.ToInt32(txtImageID.Text) + di, i + yoffset, j + xoffset]) / 255;
                        if (cbxNormalize.Checked)
                            data[i * s.windowLength + j] = Math.Round(data[i * s.windowLength + j], 1);
                        if (maxVal < data[i * s.windowLength + j])
                            maxVal = data[i * s.windowLength + j];
                    }
                }
                if (cbxLocalNormalize.Checked)
                    for (int i = 0; i < s.windowLength; i++)
                        for (int j = 0; j < s.windowLength; j++)
                            data[i * s.windowLength + j] /= maxVal;
                s.learn(data);
                //resimGoster(data, 0);
                //txtOutput.AppendText("branch = "+ s.learn(data) + "\r\n");
                //showMNISTImage(Convert.ToInt32(txtImageID.Text)+di);
                //System.Threading.Thread.Sleep(100);

            }

            txtOutput.AppendText("\n\n");
            //resimGoster[s.]
            txtOutput.AppendText(s.yazdir()+"\n");
        }

        public void fullTrain(Spektron s)
        {
            //int xoffset = Convert.ToInt32(txtXCoord.Text);
            //int yoffset = Convert.ToInt32(txtYCoord.Text);
            int windowOffset = Convert.ToInt32(txtWindowJump.Text);

            for (int di = 0; di < 900; di++)
            {
                double[] data = new double[s.branchLength];
                for (int xoffset = 0; xoffset < numRows - s.windowLength; xoffset+=windowOffset)
                    for (int yoffset = 0; yoffset < numRows - s.windowLength; yoffset+=windowOffset)
                    {
                        double maxVal = 1;
                        for (int i = 0; i < s.windowLength; i++)
                        {
                            for (int j = 0; j < s.windowLength; j++)
                            {
                                data[i * s.windowLength + j] = Convert.ToDouble(images[Convert.ToInt32(txtImageID.Text) + di, i + yoffset, j + xoffset]) / 255;
                                if (cbxNormalize.Checked)
                                    data[i * s.windowLength + j] = Math.Round(data[i * s.windowLength + j], 1);
                                if (maxVal < data[i * s.windowLength + j])
                                    maxVal = data[i * s.windowLength + j];
                            }
                        }
                        if (cbxLocalNormalize.Checked)
                            for (int i = 0; i < s.windowLength; i++)
                                for (int j = 0; j < s.windowLength; j++)
                                    data[i * s.windowLength + j] /= maxVal;
                        s.learn(data);
                    }
                //resimGoster(data, 0);
                //txtOutput.AppendText("branch = "+ s.learn(data) + "\r\n");
                //showMNISTImage(Convert.ToInt32(txtImageID.Text)+di);
                //System.Threading.Thread.Sleep(100);

            }

            txtOutput.AppendText("\n\n");
            //resimGoster[s.]
            txtOutput.AppendText(s.yazdir() + "\n");
        }


        public void test(Spektron s)
        {
            int xoffset = Convert.ToInt32(txtXCoord.Text);
            int yoffset = Convert.ToInt32(txtYCoord.Text);

            txtOutput.AppendText("\n\n");
            txtOutput.AppendText("Testing on new data\n\n");

            for (int di = 900; di < 1000; di++)
            {
                double[] data = new double[s.branchLength];
                for (int i = 0; i < s.windowLength; i++)
                    for (int j = 0; j < s.windowLength; j++)
                    {
                        data[i * s.windowLength + j] = Convert.ToDouble(images[Convert.ToInt32(txtImageID.Text) + di, i + yoffset, j + xoffset]) / 255;
                        if (cbxNormalize.Checked)
                            data[i * s.windowLength + j] = Math.Round(data[i * s.windowLength + j], 1);
                    }
                txtOutput.AppendText(di + "\t" + s.learn(data) + "\n");
                

            }
            txtOutput.AppendText(s.yazdir() + "\n");
        }
        public void resimGoster(double[] data, int imageContainer )
        {
            int zoomFactor = Convert.ToInt32(txtZoom.Text);
            int windowLen = Convert.ToInt32(Math.Sqrt(data.Length));
            Bitmap bmp = new Bitmap(windowLen * zoomFactor, windowLen * zoomFactor);
            for (int i = 0; i < windowLen; i++)
                for (int j = 0; j < windowLen; j++)
                {
                    byte b = Convert.ToByte( data[i * windowLen + j]*255);
                    for (int k = 0; k < zoomFactor; k++)
                        for (int l = 0; l < zoomFactor; l++)
                            bmp.SetPixel(j * zoomFactor + k, i * zoomFactor + l, Color.FromArgb(b, b, b));
                }
            listOutputPictureBoxes[imageContainer].Image = (Image)bmp;

            listOutputPictureBoxes[imageContainer].Show();


        }

        public void showMNISTImage(int imageID )
        {
            byte[,] pixels = new byte[28, 28];

            int zoomFactor = 3;// Convert.ToInt32(txtZoom.Text);
            Bitmap bmp = new Bitmap(28 * zoomFactor, 28 * zoomFactor);
            // each test image
            Random random = new Random();

            int di = imageID;//  random.Next(0, numImages);
            //selectedImageID = imageID;


            for (int i = 0; i < 28; ++i)
            {
                for (int j = 0; j < 28; ++j)
                {

                    pixels[i, j] = images[di, i, j];
                    byte b = pixels[i, j];
                    for (int k = 0; k < zoomFactor; k++)
                        for (int l = 0; l < zoomFactor; l++)
                            
                            bmp.SetPixel(j * zoomFactor + k, i * zoomFactor + l, Color.FromArgb(b, b, b));

                }
            }
            pictureBox1.Image = (Image)bmp;

            pictureBox1.Show();
            this.Refresh();
            txtOutput.AppendText("Label = " + labels[di] + "\t" + di + "\n\n");



        }


        /// <summary>
        /// Convolution function
        /// </summary>
        /// <param name="img"></param>
        /// <param name="filter"></param>
        /// <returns></returns>
        public byte[,] convolve(byte[,] img, double[,] filter)
        {
            int imgRows = img.GetLength(0);
            int fltRows = filter.GetLength(0);
            int imgCols = img.GetLength(1);
            int fltCols = filter.GetLength(1);

            int halfFilter = Convert.ToInt16(fltCols / 2);

            byte[,] result = new byte[img.Length, img.Length];


            Parallel.For(halfFilter, imgRows - halfFilter, i =>
            {
                for (int j = halfFilter; j < imgCols - halfFilter; j++)
                {
                    double temp = 0;
                    for (int k = 0; k < fltCols; k++)
                    {
                        for (int l = 0; l < fltCols; l++)
                            temp += img[i, j] * filter[k, l];
                    }
                    if (temp > 255)
                        temp = 255;
                    else if (temp < 0)
                        temp = 0;
                    temp = 0;

                    result[i, j] = Convert.ToByte(temp);
                }
            }); // Parallel.For
            return result;

        }
        
        /// <summary>
        /// sonuclari gosterme
        /// </summary>
        public void sonucGoster()
        {
            int zoomFactor = Convert.ToInt32(txtZoom.Text);
            

            Spektron s = new Spektron(9, Convert.ToDouble(txtHata.Text));


            //byte[,,] pixels = s.learnSpektron(images, Convert.ToInt32(txtXCoord.Text), Convert.ToInt32(txtYCoord.Text));


            for (int di = 0; di < 4; di++)
            {
                Bitmap bmp = new Bitmap(28 * zoomFactor, 28 * zoomFactor);
                byte[,] filtered = new Spektron(9, Convert.ToDouble(txtHata.Text)).convolve(selectedImageID, di);
                for (int i = 0; i < numRows - 2; ++i)
                {
                    for (int j = 0; j < numRows - 2; ++j)
                    {
                        byte b = filtered[i, j];//images[selectedImageID, i, j];
                        //pixels[di, i, j] = b;
                        for (int k = 0; k < zoomFactor; k++)
                            for (int l = 0; l < zoomFactor; l++)
                                bmp.SetPixel(j * zoomFactor + k, i * zoomFactor + l, Color.FromArgb(b, b, b));
                    }
                }

                listOutputPictureBoxes[di].Image = (Image)bmp;

                listOutputPictureBoxes[di].Show();
            }

            //txtOutput.AppendText("Label = " + labels[selectedImageID] + "\t" + selectedImageID + "\n\n");

        }

        private void BtnPrepareData_Click(object sender, EventArgs e)
        {
            byte [] img = new byte[28*28];
            for (int i = 0; i < 28 * 28; i++)
                if (i % 28 == 0)
                    img[i] = 255;
                else
                    img[i] = 0;
            Image im = byteArrayToImage(img);
            pictureBox1.Image = (Image)im;

            pictureBox1.Show();

        }

        //convert bytearray to image
        //public Image byteArrayToImage(byte[] byteArrayIn)
        //{
        //    using (MemoryStream mStream = new MemoryStream(byteArrayIn))
        //    {
        //        return Image.FromStream(mStream);
        //    }
        //}
        public Image byteArrayToImage(byte[] byteArrayIn)
        {
            //MemoryStream ms = new MemoryStream(byteArrayIn);
            //Image returnImage = Image.FromStream(ms);
            //return returnImage;
            //Bitmap im = new Bitmap(28, 28, stride,                     PixelFormat.Format8bppIndexed,                     Marshal.UnsafeAddrOfPinnedArrayElement(newbytes, 0));        
            using (MemoryStream ms = new MemoryStream(byteArrayIn))
            {
                var image = Image.FromStream(ms);
                //image.Save(filePath, System.Drawing.Imaging.ImageFormat.Png);
                return (Image)image;
            }

        }

        static byte[] PadLines(byte[] bytes, int rows, int columns)
        {
            int currentStride = columns; // 3
            int newStride = columns;  // 4
            byte[] newBytes = new byte[newStride * rows];
            for (int i = 0; i < rows; i++)
                Buffer.BlockCopy(bytes, currentStride * i, newBytes, newStride * i, currentStride);
            return newBytes;
        }

    }
}
